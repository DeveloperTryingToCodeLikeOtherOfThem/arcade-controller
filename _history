{"entries":[{"timestamp":1755362005991,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":293,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"},{"type":"added","filename":"main.ts","value":" "}]}],"snapshots":[{"timestamp":1755361983626,"editorVersion":"2.0.56","text":{"README.md":" ","assets.json":"","controller.ts":"enum UpdateControllerEvent {\n    //% block=\"connected\"\n    Connected = 1,\n    //% block=\"disconnected\"\n    Disconnected = 2\n}\n\n/**\n * Access to game controls\n */\n//% weight=98 color=\"#D54322\" icon=\"\\uf11b\"\n//% groups='[\"Single Player\", \"Multiplayer\"]'\n//% blockGap=8\nnamespace updatecontroller {\n    let _players: Controller[];\n    game.addScenePopHandler(() => {\n        const stateWhenPushed = game.currentScene().controllerConnectionState;\n        if (!stateWhenPushed)\n            return;\n        for (let i = 0; i < stateWhenPushed.length; i++) {\n            const p = _players[i];\n            if (p && (!!stateWhenPushed[i] != !!p.connected)) {\n                // connection state changed while in another scene; raise the event.\n                control.raiseEvent(\n                    p.id,\n                    p.connected ? UpdateControllerEvent.Connected : UpdateControllerEvent.Disconnected\n                );\n            }\n        }\n\n    })\n    game.addScenePushHandler(oldScene => {\n        oldScene.controllerConnectionState = [];\n        for (let i = 0; i < _players.length; i++) {\n            if (_players[i]) {\n                oldScene.controllerConnectionState[i] = _players[i].connected;\n            }\n        }\n    })\n\n    function addController(ctrl: Controller) {\n        if (!_players) {\n            _players = [];\n        }\n        _players[ctrl.playerIndex - 1] = ctrl;\n    }\n\n    export function _player1(): Controller {\n        if (!_players || !_players[0])\n            new Controller(1, [updatecontroller.left, updatecontroller.up, updatecontroller.right, updatecontroller.down, updatecontroller.A, updatecontroller.B, updatecontroller.menu]);\n        return _players[0];\n    }\n\n    export function players(): Controller[] {\n        _player1(); // ensure player1 is present\n        return _players.filter(ctrl => !!ctrl);\n    }\n\n    export class ControlledSprite {\n        public _inputLastFrame: boolean;\n        constructor(\n            public s: Sprite,\n            public vx: number,\n            public vy: number\n        ) { }\n    }\n\n    export function _moveSprites() {\n        // todo: move to current scene\n        control.enablePerfCounter(\"updatecontroller\")\n        players().forEach(ctrl => ctrl.__preUpdate());\n    }\n\n    //% fixedInstances\n    export class Controller {\n        playerIndex: number;\n        buttons: Button[];\n        analog: boolean;\n        private _id: number;\n        private _connected: boolean;\n\n        // array of left,up,right,down,a,b,menu buttons\n        constructor(playerIndex: number, buttons: Button[]) {\n            this._id = control.allocateNotifyEvent();\n            this._connected = false;\n            this.playerIndex = playerIndex;\n            this.analog = false;\n            if (buttons)\n                this.buttons = buttons;\n            else {\n                this.buttons = [];\n                const leftId = 1 + (this.playerIndex - 1) * 7;\n                for (let i = 0; i < 7; ++i) {\n                    this.buttons.push(new Button(leftId + i, -1));\n                }\n            }\n            for (let i = 0; i < this.buttons.length; ++i)\n                this.buttons[i]._owner = this;\n            addController(this);\n        }\n\n        get _controlledSprites(): ControlledSprite[] {\n            return game.currentScene().controlledSprites[this.playerIndex];\n        }\n\n        set _controlledSprites(cps: ControlledSprite[]) {\n            game.currentScene().controlledSprites[this.playerIndex] = cps;\n        }\n\n        get id() {\n            return this._id;\n        }\n\n        dump() {\n            this.buttons.forEach(b => console.log(b.toString()));\n        }\n\n        /**\n         * Get the 'Left' button\n         */\n        //%\n        get left() {\n            return this.button(UpdateControllerButton.Left);\n        }\n\n        /**\n         * Get the 'Right' button\n         */\n        //%\n        get right() {\n            return this.button(UpdateControllerButton.Right);\n        }\n\n        /**\n         * Get the 'Up' button\n         */\n        //%\n        get up() {\n            return this.button(UpdateControllerButton.Up);\n        }\n\n        /**\n         * Get the 'Down' button\n         */\n        //%\n        get down() {\n            return this.button(UpdateControllerButton.Down);\n        }\n\n        /**\n         * Get the 'A' button\n         */\n        //%\n        get A() {\n            return this.button(UpdateControllerButton.A);\n        }\n\n        /**\n         * Get the 'B' button\n         */\n        //%\n        get B() {\n            return this.button(UpdateControllerButton.B);\n        }\n\n        /**\n         * Get the 'Menu' button\n         */\n        //%\n        get menu() {\n            return this.button(7);\n        }\n\n        /**\n         * Control a sprite using the direction buttons from the updatecontroller. Note that this will overwrite\n         * the current velocity of the sprite whenever a directional button is pressed. To stop controlling\n         * a sprite, pass 0 for vx and vy.\n         *\n         * @param sprite The Sprite to control\n         * @param vx The velocity used for horizontal movement when left/right is pressed\n         * @param vy The velocity used for vertical movement when up/down is pressed\n         */\n        //% blockId=\"ctrl_control_sprite\" block=\"%controller move $sprite=variables_get(mySprite) with buttons||vx $vx vy $vy\"\n        //% weight=100\n        //% expandableArgumentMode=\"toggle\"\n        //% vx.defl=100 vy.defl=100\n        //% help=controller/move-sprite\n        //% group=\"Multiplayer\"\n        //% vx.shadow=\"spriteSpeedPicker\"\n        //% vy.shadow=\"spriteSpeedPicker\"\n        //% parts=\"multiplayer\"\n        moveSprite(sprite: Sprite, vx: number = 100, vy: number = 100) {\n            this._moveSpriteInternal(sprite, vx, vy);\n        }\n\n        stopControllingSprite(sprite: Sprite) {\n            if (!sprite) return;\n            this._controlledSprites = this._controlledSprites.filter(s => s.s.id !== sprite.id);\n        }\n\n        // use this instead of movesprite internally to avoid adding the \"multiplayer\" part\n        // to the compiled program\n        _moveSpriteInternal(sprite: Sprite, vx: number = 100, vy: number = 100) {\n            if (!sprite) return;\n            if (!this._controlledSprites) this._controlledSprites = [];\n            let cp = this._controlledSprites.find(cp => cp.s.id == sprite.id);\n            if (!cp) {\n                cp = new ControlledSprite(sprite, vx, vy);\n                this._controlledSprites.push(cp);\n            }\n            if (cp.vx && vx == 0) {\n                cp.s.vx = 0\n            }\n            if (cp.vy && vy == 0) {\n                cp.s.vy = 0\n            }\n            cp.vx = vx;\n            cp.vy = vy;\n        }\n\n        private button(button: UpdateControllerButton): Button {\n            return this.buttons[button - 1];\n        }\n\n        /**\n         * Run some code when a button is pressed, released, or held\n         */\n        //% weight=99 blockGap=8\n        //% blockId=ctrlonbuttonevent block=\"on %controller %button **button** %event\"\n        //% group=\"Multiplayer\"\n        //% help=controller/on-button-event\n        //% parts=\"multiplayer\"\n        onButtonEvent(btn: UpdateControllerButton, event: UpdateControllerEvent, handler: () => void) {\n            this.button(btn).onEvent(event, handler);\n        }\n\n        /**\n         * Register code run when a controller event occurs\n         * @param event\n         * @param handler\n         */\n        //% weight=99 blockGap=8\n        //% blockId=ctrlonevent block=\"on %controller %event\"\n        //% group=\"Multiplayer\"\n        //% help=controller/on-event\n        //% parts=\"multiplayer\"\n        onEvent(event: UpdateControllerEvent, handler: () => void) {\n            control.onEvent(this.id, event, handler);\n        }\n\n        get connected() {\n            return this._connected;\n        }\n\n        set connected(value: boolean) {\n            if (value != this._connected) {\n                this._connected = value;\n                control.raiseEvent(this.id, this._connected ? UpdateControllerEvent.Connected : UpdateControllerEvent.Disconnected);\n            }\n        }\n\n        /**\n         * Indicates if the button is currently pressed\n        */\n        //% weight=96 blockGap=8 help=controller/button/is-pressed\n        //% blockId=ctrlispressed block=\"is %controller %button **button** pressed\"\n        //% group=\"Multiplayer\"\n        //% parts=\"multiplayer\"\n        isPressed(btn: UpdateControllerButton): boolean {\n            return this.button(btn).isPressed();\n        }\n\n        /**\n         * Get the horizontal movement, given the step and state of buttons\n         * @param step the distance, eg: 100\n         */\n        //% weight=50 blockGap=8 help=controller/dx\n        //% blockId=ctrldx block=\"%controller dx (left-right buttons)||scaled by %step\"\n        //% step.defl=100\n        //% group=\"Multiplayer\"\n        //% parts=\"multiplayer\"\n        dx(step: number = 100) {\n            return this._dxInternal(step);\n        }\n\n        // use this instead of dx internally to avoid adding the \"multiplayer\" part\n        // to the compiled program\n        _dxInternal(step: number = 100) {\n            const ctx = control.eventContext();\n            if (!ctx) return 0;\n\n            if (this.analog)\n                return (this.right.pressureLevel() - this.left.pressureLevel()) / 512 * ctx.deltaTime * step\n            if (this.left.isPressed()) {\n                if (this.right.isPressed()) return 0\n                else return -step * ctx.deltaTime;\n            }\n            else if (this.right.isPressed()) return step * ctx.deltaTime\n            else return 0\n        }\n\n        /**\n         * Get the vertical movement, given the step and state of buttons\n         * @param step the distance, eg: 100\n         */\n        //% weight=49 help=controller/dy\n        //% blockId=ctrldy block=\"%controller dy (up-down buttons)||scaled by %step\"\n        //% step.defl=100\n        //% group=\"Multiplayer\"\n        //% parts=\"multiplayer\"\n        dy(step: number = 100) {\n            return this._dyInternal(step);\n        }\n\n        // use this instead of dy internally to avoid adding the \"multiplayer\" part\n        // to the compiled program\n        _dyInternal(step: number = 100) {\n            const ctx = control.eventContext();\n            if (!ctx) return 0;\n\n            if (this.analog)\n                return (this.down.pressureLevel() - this.up.pressureLevel()) / 512 * ctx.deltaTime * step\n            if (this.up.isPressed()) {\n                if (this.down.isPressed()) return 0\n                else return -step * ctx.deltaTime;\n            }\n            else if (this.down.isPressed()) return step * ctx.deltaTime\n            else return 0\n        }\n\n        __preUpdate() {\n            if (!this._controlledSprites) return;\n\n            let deadSprites = false;\n\n            let svx = 0\n            let svy = 0\n\n            if (this.analog) {\n                svx = (this.right.pressureLevel() - this.left.pressureLevel()) >> 1\n                svy = (this.down.pressureLevel() - this.up.pressureLevel()) >> 1\n            } else {\n                svx = (this.right.isPressed() ? 256 : 0) - (this.left.isPressed() ? 256 : 0)\n                svy = (this.down.isPressed() ? 256 : 0) - (this.up.isPressed() ? 256 : 0)\n            }\n\n            let svxInCricle = svx\n            let svyInCircle = svy\n\n            // here svx/y are -256 to 256 range\n            const sq = svx * svx + svy * svy\n            // we want to limit svx/y to be within circle of 256 radius\n            const max = 256 * 256\n            // is it outside the circle?\n            if (sq > max) {\n                // if so, store the vector scaled down to fit in the circle\n                const scale = Math.sqrt(max / sq)\n                svxInCricle = scale * svx | 0\n                svyInCircle = scale * svy | 0\n            }\n\n            this._controlledSprites.forEach(controlledSprite => {\n                const { s, vx, vy } = controlledSprite;\n                if (s.flags & sprites.Flag.Destroyed) {\n                    deadSprites = true;\n                    return;\n                }\n\n                if (controlledSprite._inputLastFrame) {\n                    if (vx) s._vx = Fx.zeroFx8;\n                    if (vy) s._vy = Fx.zeroFx8;\n                }\n\n                if (svx || svy) {\n                    if (vx && vy) {\n                        // if moving in both vx/vy use speed vector constrained to be within circle\n                        s._vx = Fx.imul(svxInCricle as any as Fx8, vx)\n                        s._vy = Fx.imul(svyInCircle as any as Fx8, vy)\n                    } else if (vx) {\n                        // otherwise don't bother\n                        s._vx = Fx.imul(svx as any as Fx8, vx)\n                    } else if (vy) {\n                        s._vy = Fx.imul(svy as any as Fx8, vy)\n                    }\n                    controlledSprite._inputLastFrame = true;\n                }\n                else {\n                    controlledSprite._inputLastFrame = false;\n                }\n            });\n\n            if (deadSprites)\n                this._controlledSprites = this._controlledSprites\n                    .filter(s => !(s.s.flags & sprites.Flag.Destroyed));\n        }\n\n        __update(dtms: number) {\n            dtms = dtms | 0;\n            this.buttons.forEach(btn => btn.__update(dtms));\n        }\n\n        serialize(offset: number): Buffer {\n            const buf = control.createBuffer(offset + 1);\n            let b = 0;\n            for (let i = 0; this.buttons.length; ++i)\n                b |= (this.buttons[i].isPressed() ? 1 : 0) << i;\n            buf[offset] = b\n            return buf;\n        }\n    }\n\n    /**\n     * Called by the game engine to update and/or raise events\n     */\n    export function __update(dt: number) {\n        const dtms = (dt * 1000) | 0\n        players().forEach(ctrl => ctrl.__update(dtms));\n    }\n\n    export function serialize(offset: number): Buffer {\n        return _player1().serialize(offset);\n    }\n\n    /**\n     * Control a sprite using the direction buttons from the updatecontroller. Note that this\n     * control will take over the vx and vy of the sprite and overwrite any changes\n     * made unless a 0 is passed.\n     *\n     * @param sprite The Sprite to control\n     * @param vx The velocity used for horizontal movement when left/right is pressed\n     * @param vy The velocity used for vertical movement when up/down is pressed\n     */\n    //% blockId=\"game_control_sprite\" block=\"move $sprite=variables_get(mySprite) with buttons||vx $vx vy $vy\"\n    //% weight=100\n    //% expandableArgumentMode=\"toggle\"\n    //% vx.defl=100 vy.defl=100\n    //% help=controller/move-sprite\n    //% group=\"Single Player\"\n    //% vx.shadow=spriteSpeedPicker\n    //% vy.shadow=spriteSpeedPicker\n    export function moveSprite(sprite: Sprite, vx: number = 100, vy: number = 100) {\n        _player1()._moveSpriteInternal(sprite, vx, vy);\n    }\n\n    /**\n     * Get the horizontal movement, given the step and state of buttons\n     * @param step the distance, eg: 100\n     */\n    //% weight=50 blockGap=8 help=controller/dx\n    //% blockId=keydx block=\"dx (left-right buttons)||scaled by %step\"\n    //% step.defl=100\n    //% group=\"Single Player\"\n    export function dx(step: number = 100) {\n        return _player1()._dxInternal(step);\n    }\n\n    /**\n     * Get the vertical movement, given the step and state of buttons\n     * @param step the distance, eg: 100\n     */\n    //% weight=49 help=controller/dy\n    //% blockId=keydy block=\"dy (up-down buttons)||scaled by %step\"\n    //% step.defl=100\n    //% group=\"Single Player\"\n    export function dy(step: number = 100) {\n        return _player1()._dyInternal(step);\n    }\n\n    class AnyButton extends Button {\n        isPressed(): boolean {\n            const ctrl = _player1();\n\n            for (const b of ctrl.buttons) {\n                if (b.isPressed()) return true;\n            }\n            return false;\n        }\n    }\n\n    //% fixedInstance block=\"any\"\n    export const anyButton: Button = new AnyButton(0, -1);\n}\n","controllerbutton.ts":"enum UpdateControllerEvent {\n    //% block=\"pressed\"\n    Pressed = KEY_DOWN,\n    //% block=\"released\"\n    Released = KEY_UP,\n    //% block=\"repeat\"\n    Repeated = KEY_REPEAT\n}\n\nenum UpdateControllerButton {\n    //% block=\"{id:controller}A\"\n    A = 5,\n    //% block=\"{id:controller}B\"\n    B = 6,\n    //% block=\"left\"\n    Left = 1,\n    //% block=\"up\"\n    Up = 2,\n    //% block=\"right\"\n    Right = 3,\n    //% block=\"down\"\n    Down = 4\n}\n\n/**\n * Access to game controls\n */\n//% weight=98 color=\"#D54322\" icon=\"\\uf11b\"\n//% groups='[\"Single Player\", \"Multiplayer\"]'\n//% blockGap=8\nnamespace updatecontroller {\n    let _userEventsEnabled = true;\n    let defaultRepeatDelay = 500;\n    let defaultRepeatInterval = 30;\n\n    //% shim=pxt::pressureLevelByButtonId\n    declare function pressureLevelByButtonId(btnId: number, codalId: number): number;\n\n\n    //% shim=pxt::setupButton\n    function setupButton(buttonId: number, key: number) {\n        return // missing in sim\n    }\n\n    export class ButtonHandler {\n        constructor(public event: number, public callback: () => void) { }\n    }\n\n    export class ButtonEventHandlerState {\n        constructor(public id: number) { };\n\n        public user: ButtonHandler[];\n        public system: ButtonHandler[];\n    }\n\n    //% fixedInstances\n    export class Button {\n        _owner: Controller;\n        public id: number;\n        //% help=controller/button/repeat-delay\n        public repeatDelay: number;\n        //% help=controller/button/repeat-interval\n        public repeatInterval: number;\n        private _pressed: boolean;\n        private _pressedElasped: number;\n        private _repeatCount: number;\n\n        protected get handlerState(): ButtonEventHandlerState {\n            for (const state of game.currentScene().buttonEventHandlers) {\n                if (state.id === this.id) return state;\n            }\n            return undefined;\n        }\n\n        toString(): string {\n            return `btn ${this.id} ${this._pressed ? \"down\" : \"up\"}`;\n        }\n\n        constructor(id: number, configKey: number) {\n            this.id = id;\n            this._pressed = false;\n            this.repeatDelay = undefined;\n            this.repeatInterval = undefined;\n            this._repeatCount = 0;\n\n            if (id > 0) {\n                // this is to deal with the \"anyButton\" hack, which creates a button that is not visible\n                // in the UI, but used in event-handler to simulate the wildcard ANY for matching. As\n                // this button can't actually be pressed, we don't want it to propagate events\n                control.internalOnEvent(INTERNAL_KEY_UP, this.id, () => this.setPressed(false), 16)\n                control.internalOnEvent(INTERNAL_KEY_DOWN, this.id, () => this.setPressed(true), 16)\n\n                if (configKey > 0)\n                    setupButton(id, configKey)\n            }\n        }\n\n        private raiseButtonUp() {\n            if (_userEventsEnabled)\n                control.raiseEvent(KEY_UP, this.id)\n            else\n                control.raiseEvent(SYSTEM_KEY_UP, this.id);\n        }\n\n        private raiseButtonDown() {\n            if (_userEventsEnabled)\n                control.raiseEvent(KEY_DOWN, this.id)\n            else\n                control.raiseEvent(SYSTEM_KEY_DOWN, this.id)\n        }\n\n        private raiseButtonRepeat() {\n            if (_userEventsEnabled)\n                control.raiseEvent(KEY_REPEAT, this.id)\n            else\n                control.raiseEvent(SYSTEM_KEY_REPEAT, this.id)\n        }\n\n        /**\n         * Run some code when a button is pressed, released, or held\n         */\n        //% weight=99 blockGap=8 help=controller/button/on-event\n        //% blockId=keyonevent block=\"on %button **button** %event\"\n        //% group=\"Single Player\"\n        onEvent(event: UpdateControllerEvent, handler: () => void) {\n            const eventHandler = this.getOrCreateHandlerForEvent(event);\n            eventHandler.callback = handler;\n        }\n\n        /**\n         * Adds an event handler that will fire whenever the specified event\n         * is triggered on this button. Handlers added using this method will\n         * not conflict with events added via onEvent. The same handler can\n         * not be added for the same event more than once.\n         *\n         * @param event     The event to subscribe to for this button\n         * @param handler   The code to run when the event triggers\n         */\n        addEventListener(event: UpdateControllerEvent, handler: () => void) {\n            this.getOrCreateHandlerForEvent(event);\n\n            const handlerState = this.handlerState;\n\n            if (!handlerState.system) handlerState.system = [];\n\n            for (const eventHandler of handlerState.system) {\n                if (eventHandler.event === event && eventHandler.callback === handler) return;\n            }\n\n            handlerState.system.push(new ButtonHandler(event, handler));\n        }\n\n        /**\n         * Removes an event handler registered with addEventListener.\n         *\n         * @param event     The event that the handler was registered for\n         * @param handler   The handler to remove\n         */\n        removeEventListener(event: UpdateControllerEvent, handler: () => void) {\n            const handlerState = this.handlerState;\n            if (!handlerState || !handlerState.system) return;\n\n            for (let i = 0; i < handlerState.system.length; i++) {\n                if (handlerState.system[i].event === event && handlerState.system[i].callback === handler) {\n                    handlerState.system.splice(i, 1)\n                    return;\n                }\n            }\n        }\n\n        /**\n         * Pauses until a button is pressed or released\n         */\n        //% weight=98 blockGap=8 help=controller/button/pause-until\n        // blockId=keypauseuntil block=\"pause until %button **button** is %event\"\n        //% group=\"Single Player\"\n        pauseUntil(event: UpdateControllerEvent) {\n            control.waitForEvent(event, this.id)\n        }\n\n        /**\n         * Indicates if the button is currently pressed\n         */\n        //% weight=96 blockGap=8 help=controller/button/is-pressed\n        //% blockId=keyispressed block=\"is %button **button** pressed\"\n        //% group=\"Single Player\"\n        isPressed() {\n            return this._pressed;\n        }\n\n        /**\n         * Indicates how hard the button is pressed, 0-512\n         */\n        pressureLevel() {\n            if (control.deviceDalVersion() == \"sim\") {\n                return this.isPressed() ? 512 : 0\n                // once implemented in sim, this could be similar to the one below\n            } else {\n                return pressureLevelByButtonId(this.id, -1);\n            }\n        }\n\n        setPressed(pressed: boolean) {\n            if (this._pressed != pressed) {\n                power.poke();\n                if (this._owner)\n                    this._owner.connected = true;\n                this._pressed = pressed;\n                if (this._pressed) {\n                    this._pressedElasped = 0;\n                    this.raiseButtonDown();\n                } else {\n                    this._repeatCount = 0;\n                    this.raiseButtonUp();\n                }\n            }\n        }\n\n        __update(dtms: number) {\n            if (!this._pressed) return;\n            this._pressedElasped += dtms;\n\n            const delay = this.repeatDelay === undefined ? defaultRepeatDelay : this.repeatDelay;\n            const interval = this.repeatInterval === undefined ? defaultRepeatInterval : this.repeatInterval;\n\n            // inital delay\n            if (this._pressedElasped < delay)\n                return;\n\n            // repeat count for this step\n            const count = Math.floor((this._pressedElasped - delay - interval) / interval);\n            if (count != this._repeatCount) {\n                this.raiseButtonRepeat();\n                this._repeatCount = count;\n            }\n        }\n\n        protected runButtonEvents(event: UpdateControllerEvent) {\n            const handlerState = this.handlerState;\n            if (!handlerState) return;\n\n            const userHandler = this.getOrCreateHandlerForEvent(event);\n            if (userHandler.callback) userHandler.callback();\n\n            if (handlerState.system) {\n                for (const eventHandler of handlerState.system) {\n                    if (eventHandler.event === event && eventHandler.callback) eventHandler.callback();\n                }\n            }\n        }\n\n        protected getOrCreateHandlerForEvent(event: UpdateControllerEvent) {\n            if (!this.handlerState) {\n                game.currentScene().buttonEventHandlers.push(new ButtonEventHandlerState(this.id));\n            }\n\n            const handlerState = this.handlerState;\n            if (!handlerState.user) handlerState.user = [];\n\n            for (const eventHandler of handlerState.user) {\n                if (eventHandler.event === event) {\n                    return eventHandler;\n                }\n            }\n\n            // Register actual handler if this hasn't been used before\n            control.onEvent(event, this.id, () => this.runButtonEvents(event));\n\n            const newHandler = new ButtonHandler(event, undefined);\n            handlerState.user.push(newHandler);\n            return newHandler;\n        }\n    }\n\n    /**\n     * Configures the timing of the on button repeat event for all of the controller buttons\n     * @param delay number of milliseconds from when the button is pressed to when the repeat event starts firing, eg: 500\n     * @param interval minimum number of milliseconds between calls to the button repeat event, eg: 30\n     */\n    export function setRepeatDefault(delay: number, interval: number) {\n        defaultRepeatDelay = delay;\n        defaultRepeatInterval = interval;\n    }\n\n    /**\n     * Pause the program until a button is pressed\n     */\n    //% weight=10\n    export function pauseUntilAnyButtonIsPressed() {\n        control.waitForEvent(KEY_DOWN, 0)\n    }\n\n    export function _setUserEventsEnabled(enabled: boolean) {\n        _userEventsEnabled = enabled;\n    }\n}\n","controlleroverides.ts":"namespace updatecontroller {\n    //% fixedInstance whenUsed block=\"{id:controller}A\"\n    export const A = new Button(ControllerButton.A, DAL.CFG_PIN_BTN_A);\n    //% fixedInstance whenUsed block=\"{id:controller}B\"\n    export const B = new Button(ControllerButton.B, DAL.CFG_PIN_BTN_B);\n    //% fixedInstance whenUsed block=\"left\"\n    export const left = new Button(ControllerButton.Left, DAL.CFG_PIN_BTN_LEFT);\n    //% fixedInstance whenUsed block=\"up\"\n    export const up = new Button(ControllerButton.Up, DAL.CFG_PIN_BTN_UP);\n    //% fixedInstance whenUsed block=\"right\"\n    export const right = new Button(ControllerButton.Right, DAL.CFG_PIN_BTN_RIGHT);\n    //% fixedInstance whenUsed block=\"down\"\n    export const down = new Button(ControllerButton.Down, DAL.CFG_PIN_BTN_DOWN);\n    //% fixedInstance whenUsed block=\"menu\"\n    export const menu = new Button(7, DAL.CFG_PIN_BTN_MENU);\n\n    //% fixedInstance whenUsed block=\"player 2\"\n    export const player2 = new Controller(2, undefined);\n    //% fixedInstance whenUsed block=\"player 3\"\n    export const player3 = new Controller(3, undefined);\n    //% fixedInstance whenUsed block=\"player 4\"\n    export const player4 = new Controller(4, undefined);\n    //% fixedInstance whenUsed block=\"player 1\"\n    export const player1 = controller._player1();\n}// Add your code here\n","docs/controller.md":"docs","pxt.json":"{\n    \"name\": \"arcade-controller\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"assets.json\",\n        \"controller.ts\",\n        \"controllerbutton.ts\",\n        \"controlleroverides.ts\",\n        \"docs/controller.md\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v2.0.56\",\n        \"tag\": \"v2.0.56\",\n        \"commits\": \"https://github.com/microsoft/pxt-arcade/commits/2e47d3464cf6ea715ec6e630834bbe15bc2f6feb\",\n        \"target\": \"2.0.56\",\n        \"pxt\": \"11.3.59\"\n    },\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}}],"shares":[],"lastSaveTime":1755362006007}